// Copyright 2025 Scott Friedman
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package software provides software management for HPC clusters.
package software

import (
	"fmt"
	"strings"
)

// SpackConfig holds configuration for Spack installation.
type SpackConfig struct {
	// InstallPath is where Spack will be installed (default: /opt/spack)
	InstallPath string
	// Version is the Spack version to install (default: releases/latest)
	Version string
	// CompilerPackages are compilers to install in Spack
	CompilerPackages []string
	// Packages are the packages to install
	Packages []string
}

// DefaultSpackConfig returns the default Spack configuration.
func DefaultSpackConfig() *SpackConfig {
	return &SpackConfig{
		InstallPath: "/opt/spack",
		Version:     "v0.23.0",
		CompilerPackages: []string{
			"gcc@11.3.0",
		},
	}
}

// SpackInstaller generates scripts for installing and configuring Spack.
type SpackInstaller struct {
	config *SpackConfig
}

// NewSpackInstaller creates a new Spack installer.
func NewSpackInstaller(config *SpackConfig) *SpackInstaller {
	if config == nil {
		config = DefaultSpackConfig()
	}
	return &SpackInstaller{config: config}
}

// GenerateInstallScript generates a bash script to install Spack.
func (s *SpackInstaller) GenerateInstallScript() string {
	var script strings.Builder

	script.WriteString("#!/bin/bash\n")
	script.WriteString("set -e\n\n")
	script.WriteString("# Spack Installation Script\n")
	script.WriteString("# Generated by pctl\n\n")

	// Install prerequisites
	script.WriteString("echo \"Installing Spack prerequisites...\"\n")
	script.WriteString("yum groupinstall -y \"Development Tools\"\n")
	script.WriteString("yum install -y git python3 python3-pip python3-setuptools \\\n")
	script.WriteString("  gcc gcc-c++ gcc-gfortran make patch patchelf bzip2 \\\n")
	script.WriteString("  unzip gzip tar file findutils which diffutils \\\n")
	script.WriteString("  environment-modules || true\n\n")

	// Clone Spack
	script.WriteString(fmt.Sprintf("echo \"Cloning Spack to %s...\"\n", s.config.InstallPath))
	script.WriteString(fmt.Sprintf("if [ -d \"%s\" ]; then\n", s.config.InstallPath))
	script.WriteString(fmt.Sprintf("  echo \"Spack already installed at %s\"\n", s.config.InstallPath))
	script.WriteString("else\n")
	script.WriteString(fmt.Sprintf("  git clone -c feature.manyFiles=true https://github.com/spack/spack.git %s\n", s.config.InstallPath))
	script.WriteString(fmt.Sprintf("  cd %s\n", s.config.InstallPath))
	script.WriteString(fmt.Sprintf("  git checkout %s\n", s.config.Version))
	script.WriteString("fi\n\n")

	// Source Spack environment
	script.WriteString("# Source Spack environment\n")
	script.WriteString(fmt.Sprintf(". %s/share/spack/setup-env.sh\n\n", s.config.InstallPath))

	// Initialize Spack
	script.WriteString("echo \"Initializing Spack...\"\n")
	script.WriteString("spack compiler find\n\n")

	// Configure AWS Spack buildcache
	script.WriteString("# Configure AWS Spack buildcache for faster installations\n")
	script.WriteString("echo \"Configuring AWS Spack buildcache...\"\n")
	script.WriteString("spack mirror add --scope site aws-binaries https://binaries.spack.io/releases/v0.23 || true\n")
	script.WriteString("spack buildcache keys --install --trust || true\n")
	script.WriteString("spack config add \"config:install_tree:padded_length:128\" || true\n\n")

	// Install compilers if specified
	if len(s.config.CompilerPackages) > 0 {
		script.WriteString("echo \"Installing compiler packages...\"\n")
		for _, compiler := range s.config.CompilerPackages {
			script.WriteString(fmt.Sprintf("echo \"Installing %s...\"\n", compiler))
			script.WriteString(fmt.Sprintf("spack install --fail-fast %s || echo \"Warning: Failed to install %s\"\n", compiler, compiler))
			script.WriteString(fmt.Sprintf("spack load %s || true\n", compiler))
		}
		script.WriteString("spack compiler find || true\n")
		script.WriteString("spack unload || true\n\n")
	}

	// Setup Spack for all users
	script.WriteString("# Setup Spack for all users\n")
	script.WriteString("cat > /etc/profile.d/z00_spack.sh << 'EOF'\n")
	script.WriteString(fmt.Sprintf("export SPACK_ROOT=%s\n", s.config.InstallPath))
	script.WriteString("if [ -f \"$SPACK_ROOT/share/spack/setup-env.sh\" ]; then\n")
	script.WriteString("  . $SPACK_ROOT/share/spack/setup-env.sh\n")
	script.WriteString("fi\n")
	script.WriteString("EOF\n\n")

	script.WriteString("echo \"Spack installation complete!\"\n")

	return script.String()
}

// GeneratePackageInstallScript generates a script to install Spack packages.
func (s *SpackInstaller) GeneratePackageInstallScript(packages []string) string {
	var script strings.Builder

	script.WriteString("#!/bin/bash\n")
	script.WriteString("# Spack Package Installation Script\n")
	script.WriteString("# Generated by pctl\n\n")

	// Source Spack
	script.WriteString(fmt.Sprintf(". %s/share/spack/setup-env.sh\n\n", s.config.InstallPath))

	if len(packages) == 0 {
		script.WriteString("echo \"No packages to install.\"\n")
		return script.String()
	}

	script.WriteString("echo \"Installing Spack packages...\"\n\n")

	// Group packages by type (compilers vs regular packages)
	var compilers, regularPackages []string
	for _, pkg := range packages {
		// Check if package is a compiler
		if strings.HasPrefix(pkg, "gcc@") || strings.HasPrefix(pkg, "llvm@") ||
			strings.HasPrefix(pkg, "intel-oneapi-compilers@") {
			compilers = append(compilers, pkg)
		} else {
			regularPackages = append(regularPackages, pkg)
		}
	}

	totalPackages := len(compilers) + len(regularPackages)
	currentPackage := 0

	// Base progress: Instance launch (0-10%), Spack install (10-20%)
	baseProgress := 20

	// Install compilers first (they're needed for other packages)
	if len(compilers) > 0 {
		script.WriteString("# Install compilers first\n")
		for _, compiler := range compilers {
			currentPackage++
			progress := baseProgress + (currentPackage * (80 - baseProgress) / totalPackages)
			script.WriteString(fmt.Sprintf("echo \"PCTL_PROGRESS: Installing compiler %s (%d/%d packages, %d%%)\"\n",
				compiler, currentPackage, totalPackages, progress))
			script.WriteString(fmt.Sprintf("spack install --fail-fast --use-buildcache=auto %s || \\\n", compiler))
			script.WriteString(fmt.Sprintf("  echo \"Warning: Failed to install %s\"\n", compiler))
		}
		script.WriteString("spack compiler find || true\n\n")
	}

	// Install regular packages
	if len(regularPackages) > 0 {
		script.WriteString("# Install packages (prefer buildcache, fall back to source)\n")
		// Install packages in parallel groups of 4
		script.WriteString("export SPACK_PARALLEL_JOBS=4\n\n")

		for _, pkg := range regularPackages {
			currentPackage++
			progress := baseProgress + (currentPackage * (80 - baseProgress) / totalPackages)
			script.WriteString(fmt.Sprintf("echo \"PCTL_PROGRESS: Installing %s (%d/%d packages, %d%%)\"\n",
				pkg, currentPackage, totalPackages, progress))
			script.WriteString(fmt.Sprintf("spack install --fail-fast --use-buildcache=auto %s || \\\n", pkg))
			script.WriteString(fmt.Sprintf("  echo \"Warning: Failed to install %s\"\n", pkg))
		}
	}

	script.WriteString("\necho \"PCTL_PROGRESS: Package installation complete (80%)\"\n")
	script.WriteString("spack find\n")

	return script.String()
}
